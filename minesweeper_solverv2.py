from DecodeDemcon3 import mineField
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# from celluloid import Camera

ENTER_MODE = "Expert" #"Intermediate" # "Beginner" #

if ENTER_MODE == "Beginner":
    mode = mineField.BEGINNER_FIELD
elif ENTER_MODE == "Intermediate":
    mode = mineField.INTERMEDIATE_FIELD
elif ENTER_MODE == "Expert":
    mode = mineField.EXPERT_FIELD

class mineCell:
    """Object for cell in the mine field"""
    def __init__(self, coord, prob):
        '''A mineCell can have the following states:

        mine_flagged    -- whether the cell has been flagged as a mine
        revealed        -- whether the cell has already been revealed ("clicked on")
        safe_flagged    -- whether the cell has been indicated as safe and cannot be a mine
        failed          -- the solver revealed this cell but it was a mine and failed 
        '''
        self.coordinates = coord
        self.probability = prob   
        self.mine_flagged = False
        self.revealed = False
        self.safe_flagged = False
        self.failed = False
        self.nr_surrounding_mines = -1
  
class mineFieldArray:
    """Field with all mine cell objects"""
    def __init__(self, width = int, height = int, mine_density= float):
        '''Init of the class
        
        Creates mine field array with the same size as the game field generated by MineField
        '''
        self.width = width # width of the mine field
        self.height = height # height of the mine field
        self.prev_mine_density = mine_density # number of mines in the mine field

        self.nr_flagged_mines = 0

        # generate array with mineCell objects
        self.mine_array = [[mineCell((j,i), mine_density) for j in range(width)] for i in range(height)]

        # color map for plotting the results
        self.color_map = {1: np.array([255, 0, 0]), # red
                        2: np.array([0, 255, 0]), # green
                        3: np.array([255, 255, 255]), #blue
                        4: np.array([144, 238, 144]), #light green
                        5: np.array([119, 0, 200])} #purple

    def find_cell_neighbours(self, cell, n_range = 1) -> int:
        '''Return all neighbours of a cell

        Arguments:
        cell -- mineCell object for which to find all neighbours

        Returns:
        all neighbouring mine cell objects        
        '''

        neighbours = []
        column = cell.coordinates[0]
        row = cell.coordinates[1]
        for h in range(row-n_range, row+n_range+1):
            for w in range(column-n_range, column+n_range+1):
                if ((w >= 0) & (h >= 0)) & ((w < self.width) & (h < self.height)) & (w != column or h != row):
                    neighbours.append(self.mine_array[h][w])
        return neighbours

    def mine_candidates_neighbours(self, cell) -> list:
        '''Return all neighbours that might be a mine

        Arguments:
        cell -- mineCell object of which to receive the neighbours

        Returns:
        all neighbouring mine candidates 
        '''
        mine_candidate_neighbours = []
        for n in self.find_cell_neighbours(cell):
            if (n.safe_flagged == False) & (n.mine_flagged == False):
                mine_candidate_neighbours += [n]
        return mine_candidate_neighbours

    def nr_mine_neighbours(self, cell) -> int:
        '''Return number of neighbours that are a mine

        Arguments:
        cell -- mineCell object of which to receive the number of neighbouring mines

        Returns:
        number of neighbouring mines
        '''
        mine_neighbours = 0
        #iterate over all neighbours of cell and check if they're flagged as a mine
        for n in self.find_cell_neighbours(cell):
            if n.mine_flagged == True:
                mine_neighbours += 1
        return mine_neighbours

    def mine_candidates_in_field(self) -> list:
        '''Return all cells in the field that might be a mine

        Returns:
        all mine candidates in the field
        '''
        unkown_cells = []
        for row in self.mine_array:
            for cell in row:
                #cell might be a mine if it's not marked as either safe or unsafe
                if (cell.safe_flagged != True) & (cell.mine_flagged != True):
                    unkown_cells += [cell]  
        return unkown_cells 

    def unrevealed_cells(self) -> list:
        '''Return all cells in the field that have not yet been revealed
        
        Returns:
        all unrevealed cells in the field
        '''
        unkown_cells = []
        for row in self.mine_array:
            for cell in row:
                if (cell.revealed != True) & (cell.mine_flagged != True):
                    unkown_cells += [cell]  
        return unkown_cells 

    def revealed_unsolved(self) -> list:
        '''Returns cells who have been revealed, but whos adjecent mines have not all been found yet
        
        Returns:
        All cells in field who have been revealed but whos adjecent mines have not all been found yet
        '''
        revealed_unsolved = []
        for row in self.mine_array:
            for cell in row:
                if (cell.revealed == True):
                    unkown_cell_bool = False
                    for n in self.find_cell_neighbours(cell):
                        if (n.safe_flagged == False) & (n.mine_flagged == False):
                            unkown_cell_bool = True
                    if unkown_cell_bool == True:
                        revealed_unsolved += [cell]
        return revealed_unsolved

    def mine_probability(self, cell) -> float:
        '''Return probability that mineCell is a mine

        Arguments:
        cell -- mineCell object of which to receive the mine probability for the neighbours  

        Returns:
        probability that cell is a mine (0: safe -> 1: mine)   
        '''

        # get all neigbours that might be a mine
        mine_cells = self.mine_candidates_neighbours(cell)
        nr_mine_candidates = len(mine_cells)
        if nr_mine_candidates == 0:
            # all neighbours are allready safe, so no need to calculate the mine probability for those neighbours
            return 0.
        else:
            mine_probability = (cell.nr_surrounding_mines - self.nr_mine_neighbours(cell)) / nr_mine_candidates
            return mine_probability

    def update_mine_probability_neighbours(self, cell) -> None:
        '''Update the mine probability for neighbouring cells

        Arguments:
        cell -- mineCell object of which to update the neighbours
        ''' 
        mine_probability = self.mine_probability(cell) #mine probability of neighbouring cells
        for n in self.mine_candidates_neighbours(cell):
            if (mine_probability > n.probability) or (mine_probability == 0.) or (mine_probability == 1.):
                n.probability = mine_probability #nothing fancy, I'm sure there's some way to add probabilities, but this seems to work OK..
                if n.probability >= 1.:
                    # neighbouring cell is a mine
                    n.mine_flagged = True
                    self.nr_flagged_mines += 1
                elif n.probability == 0.0:
                    # neighbouring cell is safe, but still needs to be revealed
                    n.safe_flagged = True

    def update_cells(self):
        '''Update the mine probability for the neighbours of all cells in the field that have been revealed, 
        but of which not all mines have been found yet

        '''
        for cell in self.revealed_unsolved():
            self.update_mine_probability_neighbours(cell)
        # return 

    def update_mine_field_density(self):
        '''Update the mine densitity for the remaining cells in the field
        
        '''
        # get all cells in the field that might be a mine
        check_cells = self.mine_candidates_in_field()
        if len(check_cells) > 0:
            # calculate mine density for the remaining cells
            mine_density =  (nr_mines - self.nr_flagged_mines)/len(check_cells)
            for cell in check_cells:
                # if a cell had no other probability information, update probability of the cell to mine density
                if cell.probability == self.prev_mine_density:
                    cell.probability = mine_density
            self.prev_mine_density = mine_density
    
    def what_if_cell_is_minestate(self):
        '''Determines whether there are cells of which we can deduce if they for certain are safe or a mine 
        '''
        unresolved_cells = self.revealed_unsolved()
        print('checking mine states..')

        # for all cells that have been revealed, but of which not all mines have been found yet,
        # determine the impact on a neighbouring revealed unsolved cell if one of it's neighbouring cells would be a mine,
        # or determine which cells must for certain be a mine
        for cell_i in unresolved_cells:
            remaining_mines = cell_i.nr_surrounding_mines - self.nr_mine_neighbours(cell_i)

            mine_candidates = self.mine_candidates_neighbours(cell_i)
            coord_mine_candidates = [cell.coordinates for cell in mine_candidates] #coordinates of all neighbouring mine candidate cells of the revealed unsolved cell
            
            # get all revealed unsolved neighbours of the current revealed unsolved cell
            adjecent_unresolved_cells = []
            for cell_r in unresolved_cells:
                if cell_r in self.find_cell_neighbours(cell_i, n_range = 2): #increased neighbour range 
                    adjecent_unresolved_cells += [cell_r]
            
            # find mine cells by deducing if a revealed unsolved cell can only reach its required mine number if certain cell(s) are a mine. 
            for au_cell in adjecent_unresolved_cells:
                if (au_cell.nr_surrounding_mines - self.nr_mine_neighbours(au_cell)) == 1:
                    # get coordinates of the mine candidate cells of the revealed unsolved neighbour of the revealed unsolved cell 
                    adjecent_unresolved_mine_candidates = self.mine_candidates_neighbours(au_cell)
                    coord_adjecent_unresolved_mine_candidates = [cell.coordinates for cell in adjecent_unresolved_mine_candidates]
                    unique_mine_candidates = [cell for cell in mine_candidates if cell.coordinates not in coord_adjecent_unresolved_mine_candidates]
                    
                    if (len(unique_mine_candidates) == (remaining_mines - 1)) & (len(unique_mine_candidates) != 0):
                        for cell in unique_mine_candidates:
                            cell.mine_flagged = True
                            self.nr_flagged_mines += 1
                            print('Mine cell found!')
                        self.update_cells()

            # only do this trick if the cell only has one mine left to find
            # otherwise, there are too many possibilities and this won't work
            if remaining_mines == 1:
                # mine_candidates = self.mine_candidates_neighbours(cell_i)
                # coord_mine_candidates = [cell.coordinates for cell in mine_candidates] #coordinates of all neighbouring mine candidate cells of the revealed unsolved cell
                
                # # get all revealed unsolved neighbours of the current revealed unsolved cell
                # adjecent_unresolved_cells = []
                # for cell_r in unresolved_cells:
                #     if cell_r in self.find_cell_neighbours(cell_i):
                #         adjecent_unresolved_cells += [cell_r]
                
                # loop over the mine candiates of the revealed unsolved cell to check whether this cell can be a mine
                for cell_i_n in mine_candidates:
                    coord_cell_i_n = cell_i_n.coordinates

                    # loop over the revealed unsolved neighbours of the revealed unsolved cell 
                    # to check if one of these neighbours cannot reach it's required number of neighbouring mines
                    # if the current cell is a mine
                    for cell_r in adjecent_unresolved_cells:
                        # get coordinates of the mine candidate cells of the revealed unsolved neighbour of the revealed unsolved cell 
                        adjecent_unresolved_mine_candidates = self.mine_candidates_neighbours(cell_r)
                        coord_adjecent_unresolved_mine_candidates = [cell.coordinates for cell in adjecent_unresolved_mine_candidates]

                        # There can only be an issue if current cell is a mine and does not neighbour to the current revealed unsolved neighbour
                        if coord_cell_i_n not in coord_adjecent_unresolved_mine_candidates:
                            # check how many mine cell candidates would be left for the current revealed unsolved neighbour if the current cell is a mine
                            mine_fields_left = len([coord for coord in coord_adjecent_unresolved_mine_candidates if coord not in coord_mine_candidates])

                            # if there are less mine cell candidates left for the current revealed unsolved neighbour 
                            # than that the current revealed unsolved neighbour has unresolved mines left, this would break the game.
                            # Therefore, the current cell cannot be a mine and is flagged accordingly. 
                            if mine_fields_left < (cell_r.nr_surrounding_mines - self.nr_mine_neighbours(cell_r)):
                                cell_i_n.safe_flagged = True
                                cell_i_n.probability = 0.0
                                print('Safe cell found!')
                                self.update_cells()
        return

    def sortComparatorByProb(self, item):
        '''Comparator to sort the cells by probability
        '''
        return item.probability

    def lowest_mineb_prob(self) -> list:
        '''Return all unrevealed cells in the field, 
        sorted on NOT being a mine

        Returns:
        list of all unrevealed cells in field
        '''
        check_cells = self.unrevealed_cells()
        check_cells.sort(key= self.sortComparatorByProb)
        return check_cells
    
    def return_next_cell(self):
        '''Return next cell in the field that will be revealed
        
        Returns:
        Cell in field
        '''
        # if there's no cell in the field of which we know 100% sure that it cannot be a mine,
        # check if certain cells cannot be a mine, or must be a mine
        if self.lowest_mineb_prob()[0].probability > 0:
            self.what_if_cell_is_minestate()
        return self.lowest_mineb_prob()[0] 

    def plot_minefield(self, with_timer = True, title = ""):
        '''Generate figure of the current minefield status
        '''
        # generate array for all number values that will be shown
        plot_array =  [["" for j in range(self.width)] for i in range(self.height)]
        # generate array for coloring the cells
        color_array = np.ndarray(shape=(self.height, self.width, 3), dtype=int)

        # for each cell in the field, determine the current state 
        # and determine text to be shown and color accordingly
        for r in range(0, self.height):
            for c in range(0, self.width):
                cell = self.mine_array[r][c]
                if cell.revealed == True:
                    # cell had been revealed. Show number of neighbouring mines
                    # if cell has 0 neighbours, color differently
                    plot_array[r][c] = str(cell.nr_surrounding_mines)
                    if cell.nr_surrounding_mines == 0:
                        color_array[r][c] = self.color_map[4]
                    else:
                        color_array[r][c] = self.color_map[2]
                elif (cell.mine_flagged == True) & (cell.failed == False):
                    # cell has been flagged as a mine
                    plot_array[r][c] = "x"
                    color_array[r][c] = self.color_map[1]
                elif cell.failed == True:
                    # cell was revealed, but was a mine so we failed
                    plot_array[r][c] = "x"
                    color_array[r][c] = self.color_map[5]
                else:
                    # for all cells of wich the mine state is unkown, show probability that the cell is a mine
                    plot_array[r][c] = str(round(cell.probability,2))
                    color_array[r][c] = self.color_map[3]   

        # display the plot 
        fig, ax = plt.subplots(1,1)
        ax.imshow(color_array)

        def close_event():
            plt.close() #timer calls this function after 3 seconds and closes the window 

        timer = fig.canvas.new_timer(interval = 2000) #creating a timer object and setting an interval of 3000 milliseconds
        timer.add_callback(close_event)

        # add numbers to the plot 
        for i in range(0, height):
            for j in range(0, width):
                c = plot_array[i][j]
                ax.text(j, i, c, va='center', ha='center')
        if with_timer:
            timer.start()
        
        fig_title = "nr of mines found: {}/{}".format(self.nr_flagged_mines, nr_mines)
        if title != "":
            fig_title += "\n{}".format(title)
        fig.suptitle(fig_title)

        fig.tight_layout()

        plt.show()

if __name__ == '__main__':
    width = mode['width']
    height = mode['height']
    nr_mines = mode['number_of_mines']

    # initiate the field to be solved
    mine_field = mineField.MineField(width = width, height = height, number_of_mines= nr_mines)

    # initiate the field to solve the game
    mine_density = nr_mines / (width * height)
    field = mineFieldArray(width = width, height = height, mine_density= mine_density)
    field.mine_array[0][0].probability = 0.0 # probability that the first cell is a mine is 0

    title = "We won!!!" # title for the plot

    # continue untill all mines in the field have been found
    while field.nr_flagged_mines != nr_mines:
        cell = field.return_next_cell() #next cell that will be revealed

        x = cell.coordinates[0]
        y = cell.coordinates[1]

        if cell.probability > 0:
            print("guessing at ({}, {})".format(x,y))
        try:
            # reveal cell and get adjecent mines of the cell
            adjecent_mines = mine_field.sweep_cell(x, y)
            cell.revealed = True
            cell.safe_flagged = True
            cell.nr_surrounding_mines = adjecent_mines

        except Exception:
            # we revealed a cell that was a mine
            print("I failed.. :c")
            cell.mine_flagged = True
            cell.failed = True
            title = "We lost... :c"
            break

        field.update_mine_probability_neighbours(cell) 

        field.update_mine_field_density()
        field.update_cells() # also update probability for all other cells in the field

        # field.plot_minefield(with_timer = False)

    field.plot_minefield(with_timer = False, title = title)


