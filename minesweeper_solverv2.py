from DecodeDemcon3 import mineField
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# from celluloid import Camera

ENTER_MODE = "Expert" # "Intermediate" #"Beginner" #

if ENTER_MODE == "Beginner":
    mode = mineField.BEGINNER_FIELD
elif ENTER_MODE == "Intermediate":
    mode = mineField.INTERMEDIATE_FIELD
elif ENTER_MODE == "Expert":
    mode = mineField.EXPERT_FIELD

width = mode['width']
height = mode['height']
nr_mines = mode['number_of_mines']

mine_field = mineField.MineField(width = width, height = height, number_of_mines= nr_mines)

class mineCell:
    """Object for cell in the mine field"""
    def __init__(self, coord, prob):
        self.coordinates = coord
        self.probability = prob   
        self.mine_flagged = False
        self.revealed = False
        self.safe_flagged = False
        self.failed = False
        self.nr_surrounding_mines = -1
  
class mineFieldArray:
    """Field with all mine cell objects"""
    def __init__(self, width = int, height = int, mine_density= float):
        '''Init of the class
        
        Creates mine field array with the same size as the game field generated by MineField
        '''
        self.width = width
        self.height = height
        self.prev_mine_density = mine_density

        self.nr_flagged_mines = 0

        self.mine_array = [[mineCell((j,i), mine_density) for j in range(width)] for i in range(height)]

        # color map for plotting the results
        self.color_map = {1: np.array([255, 0, 0]), # red
                        2: np.array([0, 255, 0]), # green
                        3: np.array([255, 255, 255]), #blue
                        4: np.array([144, 238, 144]), #light green
                        5: np.array([119, 0, 200])} #purple

    def find_cell_neighbours(self, cell) -> int:
        '''Return all neighbours of a cell

        Arguments:
        cell -- mineCell object for which to find all neighbours

        Returns:
        all neighbouring mine cell objects        
        '''

        neighbours = []
        column = cell.coordinates[0]
        row = cell.coordinates[1]
        for h in range(row-1, row+2):
            for w in range(column-1, column+2):
                if ((w >= 0) & (h >= 0)) & ((w < self.width) & (h < self.height)) & (w != column or h != row):
                    neighbours.append(self.mine_array[h][w])
        return neighbours

    def mine_candidates_neighbours(self, cell) -> list:
        '''Return all neighbours that might be a mine

        Arguments:
        cell -- mineCell object of which to receive the neighbours

        Returns:
        all neighbouring mine candidates 
        '''
        mine_candidate_neighbours = []
        for n in self.find_cell_neighbours(cell):
            if (n.safe_flagged == False) & (n.mine_flagged == False):
                mine_candidate_neighbours += [n]
        return mine_candidate_neighbours

    def nr_mine_neighbours(self, cell) -> int:
        '''Return number of neighbours that are a mine

        Arguments:
        cell -- mineCell object of which to receive the number of neighbouring mines

        Returns:
        number of neighbouring mines
        '''
        mine_neighbours = 0
        #iterate over all neighbours of cell and check if they're flagged as a mine
        for n in self.find_cell_neighbours(cell):
            if n.mine_flagged == True:
                mine_neighbours += 1
        return mine_neighbours

    def mine_candidates_in_field(self) -> list:
        '''Return all cells in the field that might be a mine

        Returns:
        all mine candidates in the field
        '''
        unkown_cells = []
        for row in self.mine_array:
            for cell in row:
                #cell might be a mine if it's not marked as either safe or unsafe
                if (cell.safe_flagged != True) & (cell.mine_flagged != True):
                    unkown_cells += [cell]  
        return unkown_cells 

    def unrevealed_cells(self) -> list:
        '''Return all cells in the field that have not yet been revealed
        
        Returns:
        all unrevealed cells in the field
        '''
        unkown_cells = []
        for row in self.mine_array:
            for cell in row:
                if (cell.revealed != True) & (cell.mine_flagged != True):
                    unkown_cells += [cell]  
        return unkown_cells 

    def revealed_unsolved(self) -> list:
        '''Returns cells whos adjecent mines have not all been found yet
        
        Returns:
        All cells in field who have been revealed but whos adjecent mines have not all been found yet
        '''
        revealed_unsolved = []
        for row in self.mine_array:
            for cell in row:
                if (cell.revealed == True):
                    unkown_cell_bool = False
                    for n in self.find_cell_neighbours(cell):
                        if (n.safe_flagged == False) & (n.mine_flagged == False):
                            unkown_cell_bool = True
                    if unkown_cell_bool == True:
                        revealed_unsolved += [cell]
        return revealed_unsolved

    def mine_probability(self, cell) -> float:
        '''Return probability that mineCell is a mine

        Arguments:
        cell -- mineCell object of which to receive the mine probability for the neighbours  

        Returns:
        probability that cell is a mine (0: safe -> 1: mine)   
        '''

        # get all neigbours that might be a mine
        mine_cells = self.mine_candidates_neighbours(cell)
        nr_mine_candidates = len(mine_cells)
        if nr_mine_candidates == 0:
            # all neighbours are allready safe, so no need to calculate the mine probability for those neighbours
            return 0.
        else:
            mine_probability = (cell.nr_surrounding_mines - self.nr_mine_neighbours(cell)) / nr_mine_candidates
            return mine_probability

    def update_mine_probability_neighbours(self, cell) -> None:
        '''Update the mine probability for neighbouring cells

        Arguments:
        cell -- mineCell object of which to update the neighbours
        ''' 
        mine_probability = self.mine_probability(cell) #mine probability of neighbouring cells
        for n in self.mine_candidates_neighbours(cell):
            n.probability = mine_probability #nothing fancy, I'm sure there's some way to add probabilities, but this seems to work OK..
            if n.probability >= 1.:
                # neighbouring cell is a mine
                n.mine_flagged = True
                self.nr_flagged_mines += 1
            elif n.probability == 0.0:
                # neighbouring cell is safe, but still needs to be revealed
                n.safe_flagged = True
    


    def update_cells(self):
        for cell in self.revealed_unsolved():
            self.update_mine_probability_neighbours(cell)
        return 

    def update_mine_field_density(self):
        check_cells = self.mine_candidates_in_field()
        if len(check_cells) > 0:
            mine_density =  (nr_mines - self.nr_flagged_mines)/len(check_cells)
            for cell in check_cells:
                if cell.probability == self.prev_mine_density:
                    cell.probability = mine_density
            self.prev_mine_density = mine_density
    
    def try_guessing(self):
        unresolved_cells = self.revealed_unsolved()

        for cell_i in unresolved_cells:
            remaining_mines = cell_i.nr_surrounding_mines - self.nr_mine_neighbours(cell_i)

            if remaining_mines == 1:
                mine_candidates = self.mine_candidates_neighbours(cell_i)
                coord_mine_candidates = [cell.coordinates for cell in mine_candidates]
                
                adjecent_unresolved_cells = []
                for cell_r in unresolved_cells:
                    if cell_r in self.find_cell_neighbours(cell_i):
                        adjecent_unresolved_cells += [cell_r]
                
                for cell_i_n in mine_candidates:
                    coord_cell_i_n = cell_i_n.coordinates
                    for cell_r in adjecent_unresolved_cells:
                        adjecent_unresolved_mine_candidates = self.mine_candidates_neighbours(cell_r)
                        coord_adjecent_unresolved_mine_candidates = [cell.coordinates for cell in adjecent_unresolved_mine_candidates]

                        if coord_cell_i_n not in coord_adjecent_unresolved_mine_candidates:
                            mine_fields_left = len([coord for coord in coord_adjecent_unresolved_mine_candidates if coord not in coord_mine_candidates])

                            if mine_fields_left < (cell_r.nr_surrounding_mines - self.nr_mine_neighbours(cell_r)):
                                cell_i_n.safe_flagged = True
                                cell_i_n.probability = 0.0
                                self.update_cells()
                                return
        return

    def sortComparatorByProb(self, item):
        return item.probability

    def lowest_mineb_prob(self):
        check_cells = self.unrevealed_cells()
        check_cells.sort(key= self.sortComparatorByProb)
        return check_cells
    
    def return_next_cell(self):
        if self.lowest_mineb_prob()[0].probability > 0:
            self.try_guessing()
        return self.lowest_mineb_prob()[0] 

    def plot_minefield(self, with_timer = True, title = ""):
        plot_array =  [["" for j in range(self.width)] for i in range(self.height)]
        color_array = np.ndarray(shape=(self.height, self.width, 3), dtype=int)
        for r in range(0, self.height):
            for c in range(0, self.width):
                cell = self.mine_array[r][c]
                if cell.revealed == True:
                    plot_array[r][c] = str(cell.nr_surrounding_mines)
                    if cell.nr_surrounding_mines == 0:
                        color_array[r][c] = self.color_map[4]
                    else:
                        color_array[r][c] = self.color_map[2]
                elif (cell.mine_flagged == True) & (cell.failed == False):
                    plot_array[r][c] = "x"
                    color_array[r][c] = self.color_map[1]
                elif cell.failed == True:
                    plot_array[r][c] = "x"
                    color_array[r][c] = self.color_map[5]
                else:
                    plot_array[r][c] = str(round(cell.probability,2))
                    color_array[r][c] = self.color_map[3]   

        # display the plot 
        fig, ax = plt.subplots(1,1)
        ax.imshow(color_array)

        def close_event():
            plt.close() #timer calls this function after 3 seconds and closes the window 

        timer = fig.canvas.new_timer(interval = 2000) #creating a timer object and setting an interval of 3000 milliseconds
        timer.add_callback(close_event)
        # add numbers to the plot 
        # thanks to tmdavison answer here https://stackoverflow.com/a/40890587/7871710
        for i in range(0, height):
            for j in range(0, width):
                c = plot_array[i][j]
                ax.text(j, i, c, va='center', ha='center')
        if with_timer:
            timer.start()
        
        fig_title = "nr of mines found: {}/{}".format(self.nr_flagged_mines, nr_mines)
        if title != "":
            fig_title += "\n{}".format(title)
        fig.suptitle(fig_title)

        fig.tight_layout()

        plt.show()

mine_density = nr_mines / (width * height)
field = mineFieldArray(width = width, height = height, mine_density= mine_density)
field.mine_array[0][0].probability = 0.0


title = "We won!!!"
while field.nr_flagged_mines != nr_mines:
    item = field.return_next_cell()

    x = item.coordinates[0]
    y = item.coordinates[1]

    if item.probability > 0:
        print("guessing at ({}, {})".format(x,y))
    try:
        adjecent_mines = mine_field.sweep_cell(x, y)
        item.revealed = True
        item.safe_flagged = True
        item.nr_surrounding_mines = adjecent_mines

    except Exception:
        print("I failed.. :c")
        item.mine_flagged = True
        item.failed = True
        title = "We lost... :c"
        break

    field.update_mine_probability_neighbours(item)

    field.update_mine_field_density()
    field.update_cells()
    # field.plot_minefield(with_timer = False)
field.plot_minefield(with_timer = False, title = title)


